### 시스템프로그래밍 1주차 과제
##### 32230250 권민성

<br><br><br>

**환경 구축**  
Microsoft의 공식 문서를 참고하여 wsl환경에서 vscode를 코드 편집기로 사용할 수 있는 환경을 구축했다.  
우분투의 사용을 편리하게 하기 위해 docker 컨테이너를 이용해 wsl을 관리하도록 하였다.  
우분투 버전의 경우 24.04.1 LTS를 사용했다.  
  
[wsl과 vscode연동 가이드](https://learn.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-vscode)  
[wsl에서 docker container사용 가이드](https://learn.microsoft.com/ko-kr/windows/wsl/tutorials/wsl-containers)  

<br>

**프로그램 소스코드 작성**  
삽입, 삭제, 검색, 리스트 기능의 구현을 위해 python의 `dictionary`와 유사한 기능을 가진 `key-value` 컨테이너를 구현하기로 했다.  
전화번호부의 컨셉에 맟추어, `key`는 `string`으로, `value`는 정수로 자료형을 지정했다.  
C 환경에서도 `#include <string.h>`를 이용하여 C++과 유사한 형태로 문자열을 조작할 수 있다.  
하지만 최초 선언에서는 `char*`형태로 선언해야 하며, 연산자 오버로딩이 없는 C언어의 특성에 따라
`문자열A==문자열B`와 같은 비교는 불가능하다.  
C++ STL `unordered_map`의 구조를 틀로 잡아 기능과 인터페이스를 설정하였고, 힙 메모리의 할당의 경우 C++ STL `vector`의 구조와 유사하게 진행하였다.  
C언어에는 C++과 달리 클래스 개념이 존재하지 않으므로, 함수 포인터를 이용하여 구조체 안의 포인터 멤버 변수와 함수를 연동하는 방식으로 클래스와 유사한 구조를 구현했다.  
소스 코드 파일을 두 개 이상 사용해야 하므로, `.h`확장자를 가진 헤더 파일과 `.c`확장자를 가진 소스 파일로 나누어 작업했다.  
헤더 파일이 구조체의 원형을, 소스 파일은 구체적 구현을 가지도록 작업했으며, 또 다른 `.c` 소스 파일에 드라이버 코드를 구성하여 테스트를 진행했다.  
드라이버 코드를 통해 컨테이너의 올바른 작동을 확인하였고, 이후 사용자 입력으로 동작하는 main.c파일을 작성하였다.  

<br>

소스 코드는 다음과 같으며, 이 markdown파일이 있는 branch에서 소스 파일을 확인할 수 있다.  
소스 파일에 있는 코드에는 드라이버 코드가 아닌 사용자 입력을 통해 동작하는 `main.c` 파일이 포함된다.
- Phonebook.h
```c
#ifndef DICTIONARY_H
#define DICTIONARY_H

#include <stdlib.h>

typedef struct KeyValue {
    char* Key;
    int Value;
} KeyValue;

typedef struct Dictionary {
    KeyValue* Items;
    size_t Size;
    size_t Capacity;
    
    void (*Insert)(struct Dictionary*, const char*, int);
    void (*Remove)(struct Dictionary*, const char*);
    int (*Search)(struct Dictionary*, const char*);
    void (*List)(struct Dictionary*);
} Dictionary;

Dictionary* CreateDictionary();
void DestroyDictionary(Dictionary* dict);

#endif // DICTIONARY_H
```
- Phonebook.c
```c
#include "Phonebook.h"
#include <stdio.h>
#include <string.h>

#define INITIAL_CAPACITY 4

static void Insert(Dictionary* dict, const char* key, int value) {
    if (dict->Size >= dict->Capacity) {
        dict->Capacity *= 2;
        dict->Items = realloc(dict->Items, dict->Capacity * sizeof(KeyValue));
    }

    dict->Items[dict->Size].Key = strdup(key);
    dict->Items[dict->Size].Value = value;
    dict->Size++;
}

static void RemoveItem(Dictionary* dict, const char* key) {
    for (size_t i = 0; i < dict->Size; i++) {
        if (strcmp(dict->Items[i].Key, key) == 0) {
            free(dict->Items[i].Key);
            dict->Items[i] = dict->Items[dict->Size - 1];
            dict->Size--;
            return;
        }
    }
}

static int Search(Dictionary* dict, const char* key) {
    for (size_t i = 0; i < dict->Size; i++) {
        if (strcmp(dict->Items[i].Key, key) == 0) {
            return dict->Items[i].Value;
        }
    }
    return -1;
}

static void List(Dictionary* dict) {
    for (size_t i = 0; i < dict->Size; i++) {
        printf("Name: %s, Phone Number: %d\n", dict->Items[i].Key, dict->Items[i].Value);
    }
}

Dictionary* CreateDictionary() {
    Dictionary* dict = (Dictionary*)malloc(sizeof(Dictionary));
    dict->Items = (KeyValue*)malloc(INITIAL_CAPACITY * sizeof(KeyValue));
    dict->Size = 0;
    dict->Capacity = INITIAL_CAPACITY;

    // Assign function pointers
    dict->Insert = Insert;
    dict->Remove = RemoveItem;
    dict->Search = Search;
    dict->List = List;

    return dict;
}

void DestroyDictionary(Dictionary* dict) {
    for (size_t i = 0; i < dict->Size; i++) {
        free(dict->Items[i].Key);
    }
    free(dict->Items);
    free(dict);
}
```
- Driver.c
```c
#include <stdio.h>
#include "Phonebook.h"

int main() {
    Dictionary* dict = CreateDictionary();
    
    dict->Insert(dict, "Alice", 30);
    dict->Insert(dict, "Bob", 25);
    dict->Insert(dict, "Charlie", 35);
    
    printf("List of dictionary items:\n");
    dict->List(dict);
    
    printf("Searching for Bob: %d\n", dict->Search(dict, "Bob"));
    
    dict->Remove(dict, "Alice");
    
    printf("List after removing Alice:\n");
    dict->List(dict);
    
    DestroyDictionary(dict);
    return 0;
}
```

![바이너리 코드 실행 결과](https://github.com/minsung-kwon/SystemProgramming/blob/phonebook/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-09-26%20180424.png)

<br>

**참고 문헌**  
[Microsoft C++ STL `vector` 설명서](https://learn.microsoft.com/ko-kr/cpp/standard-library/vector?view=msvc-170)  
[Microsoft C++ STL `unordered_map` 설명서](https://learn.microsoft.com/ko-kr/cpp/standard-library/unordered-map?view=msvc-170)  
Microsoft에서 제공하는 해당 STL에 대한 가이드에서 “`vector` 클래스”, “`unordered_map` 클래스” 문서에 구현/메모리 할당 방식에 대한 대략적인 설명을 제공한다.  
