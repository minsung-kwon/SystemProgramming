### 시스템프로그래밍 2차 과제
##### 32230250 권민성

<br><br><br>

**프로그램 소스코드 작성**  
리눅스 명령어 'ls'의 하위 기능 '-l', '-R', '-a'를 구현하기로 했다.  
'-l'은 권한, 링크 수, 소유자, 그룹, 파일 크기, 최종 수정 시간, 피일명을 출력한다.  
'-R'은 재귀적 출력을 통해 모든 하위 디렉토리의 내용도 출력한다.  
'-a'는 숨겨진 파일을 포함하여 모든 파일을 나열합니다.
<br><br>
다음은 소스 코드입니다.
```c
#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
#include <sys/types.h>

#define INITIAL_PATH_SIZE 256
#define DT_DIR_VALUE 4

void PrintFileInformation(const char *directoryName, struct dirent *directoryEntry, int showHiddenFiles, int displayLongList) {
    if (!showHiddenFiles && directoryEntry->d_name[0] == '.') {
        return;
    }

    if (displayLongList) {
        char *filePath = (char *)malloc(INITIAL_PATH_SIZE * sizeof(char));
        size_t pathSize = INITIAL_PATH_SIZE;

        while (snprintf(filePath, pathSize, "%s/%s", directoryName, directoryEntry->d_name) >= pathSize) {
            pathSize *= 2;
            filePath = (char *)realloc(filePath, pathSize * sizeof(char));
        }

        struct stat fileStatus;
        if (stat(filePath, &fileStatus) == -1) {
            perror("stat");
            free(filePath);
            return;
        }

        printf((S_ISDIR(fileStatus.st_mode)) ? "d" : "-");
        printf((fileStatus.st_mode & S_IRUSR) ? "r" : "-");
        printf((fileStatus.st_mode & S_IWUSR) ? "w" : "-");
        printf((fileStatus.st_mode & S_IXUSR) ? "x" : "-");
        printf((fileStatus.st_mode & S_IRGRP) ? "r" : "-");
        printf((fileStatus.st_mode & S_IWGRP) ? "w" : "-");
        printf((fileStatus.st_mode & S_IXGRP) ? "x" : "-");
        printf((fileStatus.st_mode & S_IROTH) ? "r" : "-");
        printf((fileStatus.st_mode & S_IWOTH) ? "w" : "-");
        printf((fileStatus.st_mode & S_IXOTH) ? "x" : "-");

        struct passwd *password = getpwuid(fileStatus.st_uid);
        struct group *group = getgrgid(fileStatus.st_gid);

        printf(" %ld %s %s %ld ", fileStatus.st_nlink, password->pw_name, group->gr_name, fileStatus.st_size);

        char timeBuffer[80];
        struct tm *timeInformation = localtime(&fileStatus.st_mtime);
        strftime(timeBuffer, sizeof(timeBuffer), "%b %d %H:%M", timeInformation);
        printf("%s ", timeBuffer);

        free(filePath);
    }

    printf("%s\n", directoryEntry->d_name);
}

void ListFilesInDirectory(const char *directory, int showHiddenFiles, int displayLongList, int performRecursiveSearch) {
    struct dirent *directoryEntry;
    DIR *directoryPointer;

    directoryPointer = opendir(directory);
    if (directoryPointer == NULL) {
        perror("opendir");
        return;
    }

    while ((directoryEntry = readdir(directoryPointer)) != NULL) {
        PrintFileInformation(directory, directoryEntry, showHiddenFiles, displayLongList);
    }

    if (performRecursiveSearch) {
        rewinddir(directoryPointer);

        while ((directoryEntry = readdir(directoryPointer)) != NULL) {
            if (directoryEntry->d_type != DT_DIR_VALUE || strcmp(directoryEntry->d_name, ".") == 0 || strcmp(directoryEntry->d_name, "..") == 0) {
                continue;
            }

            char *nextDirectory = (char *)malloc(INITIAL_PATH_SIZE * sizeof(char));
            size_t pathSize = INITIAL_PATH_SIZE;

            while (snprintf(nextDirectory, pathSize, "%s/%s", directory, directoryEntry->d_name) >= pathSize) {
                pathSize *= 2;
                nextDirectory = (char *)realloc(nextDirectory, pathSize * sizeof(char));
            }

            printf("\n%s:\n", nextDirectory);
            ListFilesInDirectory(nextDirectory, showHiddenFiles, displayLongList, performRecursiveSearch);

            free(nextDirectory);
        }
    }

    closedir(directoryPointer);
}

int main(int argumentCount, char *argumentValues[]) {
    int showHiddenFiles = 0;
    int displayLongList = 0;
    int performRecursiveSearch = 0;

    const char *directory = ".";

    for (int i = 1; i < argumentCount; i++) {
        if (argumentValues[i][0] == '-') {
            for (int j = 1; argumentValues[i][j] != '\0'; j++) {
                switch (argumentValues[i][j]) {
                    case 'a': showHiddenFiles = 1; break;
                    case 'l': displayLongList = 1; break;
                    case 'R': performRecursiveSearch = 1; break;
                    default:
                        printf("Unknown option: %c\n", argumentValues[i][j]);
                        return EXIT_FAILURE;
                }
            }
        } else {
            directory = argumentValues[i];
        }
    }

    ListFilesInDirectory(directory, showHiddenFiles, displayLongList, performRecursiveSearch);

    return EXIT_SUCCESS;
}
```
환경에서 <dirent.h> 가 작동하지 않아 DT_DIR을 사용할 수 없어 개발 환경의 local DT_DIR size인 4를 사용했다.  
`#define DT_DIR_VALUE 4` 
함수에는 PascalCase, 변수에는 camelCase를 사용하여 구성하였고, 가독성을 위해 단어를 축약하지 않았다.  
디렉토리에 있는 파일/디렉토리를 출력할 때, 출력하는 배열의 크기를 정해야 하는데 이때 동적할당을 사용했다.  
코드 컴파일 이후 파일이 추가/삭제될 것을 고려하여 C++ STL <vector>와 같은 할당 방식을 사용했다.  
사용된 리눅스 관련 헤더 파일 `<dirent.h>, <sys/stat.h>, <unistd.h>, <sys/types.h>`  
의 경우 공식 문서를 참조하여 사용했습니다.  
<br>
**실행 방식**  
`gcc -o "임의의 실행 파일경로" "c 파일명".c`를 통해 코드를 빌드한다.  
이후 임의의 디렉토리에서 `./"실행파일경로"`를 입력하면 기본 ls명령어가 실행된다.  
위와 같이 입력하고 뒤에 '-l', '-R', '-a'등을 붙이면 해당 멸령어로 실행된다.
<br>
**참고 문헌**  
[<dirent.h> 셜명서](https://www.ibm.com/docs/ko/aix/7.3?topic=files-direnth-file)  
[<sys/stat.h> 설명서](https://pubs.opengroup.org/onlinepubs/7908799/xsh/sysstat.h.html)  
[<unistd.h> 설명서](https://www.ibm.com/docs/ko/aix/7.2?topic=files-unistdh-file)  
[<pwd.h> 설명서](https://www.ibm.com/docs/ko/aix/7.3?topic=files-pwdh-file)  
[<grp.h> 설명서](https://www.ibm.com/docs/ko/aix/7.3?topic=files-grph-file)  
[<sys/types.h> 설명서](https://pubs.opengroup.org/onlinepubs/009604599/basedefs/sys/types.h.html)
